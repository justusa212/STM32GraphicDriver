#include <string.h>
#include <stdio.h>

#include "babydriver.h"
#include "fonts.h"

uint8_t BD_FRAMEBUFFER[BD_FB_SIZE] = {0};

void bd_print_framebuffer() {

	for (int y = 0; y < BD_FB_HEIGHT; y++) {
		for (int x = 0; x < BD_FB_WIDTH; x++) {

			if (bd_get_pixel(x, y)) {
				printf("1");
			} else {
				printf("0");
			}
		}

		printf("\n");
	}
}

void bd_fill_framebuffer(bool colour) {

	memset(BD_FRAMEBUFFER, colour ? 0xFF : 0x00, BD_FB_SIZE);
}

void bd_set_pixel(int x, int y, bool state) {

	int pos = (BD_FB_HEIGHT * x + y) >> 3;

	if (state) {

		BD_FRAMEBUFFER[pos] |= (0x80 >> (y & 0x7));
	} else {

		BD_FRAMEBUFFER[pos] &= ~(0x80 >> (y & 0x7));
	}
}

bool bd_get_pixel(int x, int y) {

	int pos = (BD_FB_HEIGHT * x + y) >> 3;

	return BD_FRAMEBUFFER[pos] & (0x80 >> (y & 0x7));
}

void bd_draw_rectangle(int x, int y, int width, int height) {

	for (int i = x; i < x + width; i++) {
		for (int j = y; j < y + height; j++) {

			if (j < BD_FB_HEIGHT) {
				bd_set_pixel(i, j, true);
			}
		}

		if (i >= BD_FB_WIDTH) {
			return;
		}
	}
}

void bd_draw_rdiagonal(int x, int y, int width, int height) {

	int offset = 0;

	for (int j = y; j < y + height; j++) {
		for (int i = x; i < x + width; i++) {

			bd_set_pixel(i + offset, j, true);
		}

		offset += 1;
	}
}

void bd_draw_ldiagonal(int x, int y, int width, int height) {

	int offset = 0;

	for (int j = y; j < y + height; j++) {
		for (int i = x; i < x + width; i++) {

			bd_set_pixel(i - offset, j, true);
		}

		offset += 1;
	}
}

void bd_draw_triangle(int x, int y, int side, int width) {

	bd_draw_rdiagonal(x + side, y, width, side);
	bd_draw_ldiagonal(x + side, y, width, side);
	bd_draw_rectangle(x + width, y + side, side*2, 1);
}

void bd_draw_bitmap(int x, int y, int width, int height, const uint8_t *bitmap) {

	uint8_t chkMsk = 0;
	int size = width * height >> 3;

	int originalX = x;
	int originalY = y;

	for (int i = 0; i < size; i++) {
		for (int j = 0; j < 8; j++) {

			chkMsk = 0x80 >> j;

			bd_set_pixel(x, y, bitmap[i] & chkMsk);
			x++;

			if ((x - originalX) == width) {

				y++;
				x = originalX;
			}

			if ((y - originalY) == height) {
				return;
			}

			if (y > BD_FB_HEIGHT) {
				return;
			}

		}
	}
}

void bd_draw_text(int x, int y, int size, char *text) {

	const uint8_t *font;
	const uint8_t *drawChar;

	int runningX = x;
	int runningY = y;

	int target;

	switch (size) {

		case 16:
		default:
			font = CGA16;
	}

	for (int i = 0; i < strlen(text); i++) {

		if (runningX >= BD_FB_WIDTH) {

			runningX = x;
			runningY += size;
		}

		if (runningY >= BD_FB_HEIGHT) {
			return;
		}

		target = (size*size >> 3) * (text[i] - ' ');
		drawChar = font + target;

		bd_draw_bitmap(runningX, runningY, size, size, drawChar);

		runningX += size;
	}
}

/* NOTE: BEGIN PHYSICAL COMMS */

//Full refresh waveform, refresh time 800ms
const uint8_t LUT_R20_GC[] = {

	0x01,	0x00,	0x14,	0x14,	0x01,	0x01,	0x00,	0x01,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
};

const uint8_t LUT_R21_GC[] = {

	0x01,	0x60,	0x14,	0x14,	0x01,	0x01,	0x00,	0x01,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
};

const uint8_t LUT_R22_GC[] = {

	0x01,	0x60,	0x14,	0x14,	0x01,	0x01,	0x00,	0x01,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
};

const uint8_t LUT_R23_GC[] = {

	0x01,	0x90,	0x14,	0x14,	0x01,	0x01,	0x00,	0x01,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
};

const uint8_t LUT_R24_GC[] = {

	0x01,	0x90,	0x14,	0x14,	0x01,	0x01,	0x00,	0x01,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
};

// Partially refresh waveform, screen refresh time 400ms
const uint8_t LUT_R20_DU[] = {

	0x01,	0x00,	0x14,	0x01,	0x01,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
};

const uint8_t LUT_R21_DU[] = {
	0x01,	0x20,	0x14,	0x01,	0x01,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
};

const uint8_t LUT_R22_DU[] = {

	0x01,	0x80,	0x14,	0x01,	0x01,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
};

const uint8_t LUT_R23_DU[] = {

	0x01,	0x40,	0x14,	0x01,	0x01,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
};

const unsigned char LUT_R24_DU[] = {

	0x01,	0x00,	0x14,	0x01,	0x01,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,	0x00,
};

bd_state_s State = {

	.lutState = 0,
	.upTo = 0,
	.doBorder = false,
	.initialised = false
};

void bd_dummy_tx(uint8_t byte) {;}
void bd_dummy_cd(bool state) {;}
void bd_dummy_cs(bool state) {;}

void (*bd_spi_tx)(uint8_t byte) = &bd_dummy_tx;
void (*bd_set_cd)(bool state) = &bd_dummy_cd;
void (*bd_set_cs)(bool state) = &bd_dummy_cs;

void bd_set_spi_tx(void (*spi_tx)(uint8_t byte)) {

	bd_spi_tx = spi_tx;
}

void bd_set_set_cd(void (*set_cd)(bool state)) {

	bd_set_cd = set_cd;
}

void bd_set_set_cs(void (*set_cs)(bool state)) {

	bd_set_cs = set_cs;
}

void bd_tx_cmd(uint8_t cmd) {

	bd_set_cd(false);
	bd_spi_tx(cmd);
}

void bd_tx_data(uint8_t data) {

	bd_set_cd(true);
	bd_spi_tx(data);
}

void bd_power_on() {

	bd_set_cd(false);
	bd_spi_tx(BD_COM_PON);
}

void bd_power_off() {

	bd_set_cd(false);
	bd_spi_tx(BD_COM_OFF);
}

void bd_refresh() {

	State.doBorder = true;

	bd_tx_cmd(BD_COM_AUTO);
	bd_tx_data(BD_AUTO_PON_DRF_POF);
}

void bd_lut_tx(bd_luttype_e type) {

	const uint8_t *r20 = LUT_R20_GC;
	const uint8_t *r21 = LUT_R21_GC;
	const uint8_t *r24 = LUT_R24_GC;

	const uint8_t *firstLUT = LUT_R22_GC;
	const uint8_t *secondLUT = LUT_R23_GC;

	if (type == BD_LUT_T_DU) {

		r20 = LUT_R20_DU;
		r21 = LUT_R21_DU;
		r24 = LUT_R24_DU;

		firstLUT = LUT_R22_DU;
		secondLUT = LUT_R23_DU;
	}

	bd_set_cd(false);
	bd_spi_tx(BD_COM_LUTC);

	bd_set_cd(true);
	for (int i = 0; i < 56; i++) {

		bd_spi_tx(r20[i]);
	}

	bd_set_cd(false);
	bd_spi_tx(BD_COM_LUTWW);

	bd_set_cd(true);
	for (int i = 0; i < 56; i++) {

		bd_spi_tx(r21[i]);
	}

	bd_set_cd(false);
	bd_spi_tx(BD_COM_LUTKK);

	bd_set_cd(true);
	for (int i = 0; i < 56; i++) {

		bd_spi_tx(r24[i]);
	}

	if (State.lutState) {

		if (type == BD_LUT_T_DU) {

			firstLUT = LUT_R23_DU;
			secondLUT = LUT_R22_DU;
		} else {

			firstLUT = LUT_R23_GC;
			secondLUT = LUT_R22_GC;
		}
	}

	bd_set_cd(false);
	bd_spi_tx(BD_COM_LUTKW);

	bd_set_cd(true);
	for (int i = 0; i < 56; i++) {

		bd_spi_tx(firstLUT[i]);
	}

	bd_set_cd(false);
	bd_spi_tx(BD_COM_LUTWK);

	bd_set_cd(true);
	for (int i = 0; i < 56; i++) {

		bd_spi_tx(secondLUT[i]);
	}

	State.lutState = !State.lutState;
}

void bd_render_framebuffer(bool fullRefresh) {

	if (State.doBorder) {

		bd_tx_cmd(BD_COM_CDI);
		bd_tx_data(0xD7);
	}

	bd_tx_cmd(BD_COM_DTM2);
	for (int i = 0; i < BD_FB_SIZE; i++) {

		bd_tx_data(BD_FRAMEBUFFER[i]);
	}

	bd_lut_tx(State.initialised && !fullRefresh ? BD_LUT_T_DU : BD_LUT_T_GC);
	bd_refresh();

	State.initialised = true;
}

void bd_init() {

	bd_tx_cmd(BD_COM_PSR);
	bd_tx_data(BD_PSR_FULL_LANDSCAPE);

	bd_tx_cmd(BD_COM_PWR);

	bd_tx_data(BD_PWR_VSG_18V);
	bd_tx_data(BD_PWR_VGHL_20V);
	bd_tx_data(BD_PWR_VSH_15V);
	bd_tx_data(BD_PWR_VSL_15V);
	bd_tx_data(BD_PWR_VDHR_2v8);

	bd_tx_cmd(BD_COM_PFS);
	bd_tx_data(BD_PFS_VDOFF_1F);

	bd_tx_cmd(BD_COM_BTST);
	bd_tx_data(BD_BTST_PHA_10_5_658);
	bd_tx_data(BD_BTST_PHB_10_5_658);
	bd_tx_data(BD_BTST_PHC_6_658);

	bd_tx_cmd(BD_COM_PLL);
	bd_tx_data(BD_PLL_FRS_50);

	bd_tx_cmd(BD_COM_TCON);
	bd_tx_data(BD_TCON_SG_12_12);

	bd_tx_cmd(BD_COM_VDCS);
	bd_tx_data(BD_VCOM_AMV_3S);

	bd_tx_cmd(BD_COM_PWS);
	bd_tx_data(BD_PWS_LVD_2v2);

	bd_tx_cmd(BD_COM_TSE);
	bd_tx_data(BD_TSE_ENABLE);

	bd_tx_cmd(BD_COM_TRES);
	bd_tx_data(BD_FB_HEIGHT);
	bd_tx_data(0x00);
	bd_tx_data(BD_FB_WIDTH - 1);

	bd_tx_cmd(BD_COM_GSST);
	bd_tx_data(BD_GSST_HST_NIL);
	bd_tx_data(BD_GSST_VST_NIL);
	bd_tx_data(BD_GSST_VST_NIL);

	bd_tx_cmd(BD_COM_CDI);
	bd_tx_data(BD_CDI_LUTW_LUTW_10);

}
